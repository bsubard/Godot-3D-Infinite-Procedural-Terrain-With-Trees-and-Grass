# Chunk.gd
# Generates and holds the data for a single segment of the world,
# including terrain mesh, water, grass, and trees.

extends Node3D

# --- Node References ---
@export var mesh_instance: MeshInstance3D
@export var collision_shape: CollisionShape3D
@export var water_mesh_instance: MeshInstance3D
@export var grass_multimesh: MultiMeshInstance3D
@export var tree_multimesh: MultiMeshInstance3D
@export var rock_multimesh: MultiMeshInstance3D

# --- Chunk Configuration ---
@export_group("Chunk Size")
@export var chunk_size_x: int = 32
@export var chunk_size_z: int = 32
@export var vertices_x: int = 33
@export var vertices_z: int = 33

# --- Path Rules ---
@export_group("Path Rules")
## The width of the path generated by noise. Smaller values = wider paths.
@export var path_width: float = 0.05
## Any terrain triangle with an average path influence above this will not spawn foliage.
@export var path_culling_threshold: float = 0.1

# --- Terrain Generation ---
@export_group("Base Continent")
@export var noise_continent: FastNoiseLite
@export var continent_slope_scale: float = 8.0
@export var continent_min_height: float = -10.0
@export var continent_max_height: float = 25.0
@export_group("Mountain Control")
@export var noise_mountain: FastNoiseLite
@export var mountain_scale: float = 40.0
@export var mountain_start_height: float = 10.0
@export var mountain_fade_height: float = 10.0
@export_group("Valley Control")
@export var noise_valley: FastNoiseLite
@export var valley_carve_scale: float = 15.0
@export var valley_apply_threshold: float = 5.0
@export_group("Erosion Control")
@export var noise_erosion: FastNoiseLite
@export var erosion_scale: float = 2.5

# --- Water Plane ---
@export_group("Water Plane")
@export var visual_water_level: float = -2.0

# --- Grass Placement Rules ---
@export_group("Grass Placement Rules")
@export var grass_material: Material
@export var grass_min_height: float = 2.5
@export var grass_max_height: float = 79.0
@export var grass_max_slope_normal_y: float = 0.8
@export var grass_density: float = 0.1

# --- Grass Randomization ---
@export_group("Grass Randomization")
@export var grass_rotation_min_degrees: Vector3 = Vector3(80, 0, -5)
@export var grass_rotation_max_degrees: Vector3 = Vector3(100, 360, 5)
@export var grass_scale_min: float = 0.8
@export var grass_scale_max: float = 1.3

# --- Grass LOD ---
@export_group("Grass LOD")
@export var lod_distances: PackedFloat32Array = [80.0, 160.0, 240.0]
@export var lod_density_multipliers: PackedFloat32Array = [1.0, 0.5, 0.2, 0.0]

# --- Tree Placement Rules ---
@export_group("Tree Placement Rules")
@export var tree_trunk_material: Material
@export var tree_leaves_material: Material
@export var tree_min_height: float = 5.0
@export var tree_max_height: float = 60.0
@export var tree_max_slope_normal_y: float = 0.9
@export var tree_density: float = 0.005

# --- Tree Randomization ---
@export_group("Tree Randomization")
@export var tree_scale_min: float = 0.7
@export var tree_scale_max: float = 1.1

# --- NEW: Rock Placement Rules ---
@export_group("Rock Placement Rules")
@export var rock_material: Material
@export var rock_min_height: float = -5.0
@export var rock_max_height: float = 80.0
@export var rock_max_slope_normal_y: float = 0.95
@export var rock_density: float = 0.002

# --- NEW: Rock Randomization ---
@export_group("Rock Randomization")
@export var rock_scale_min: float = 0.2
@export var rock_scale_max: float = 0.8
@export var rock_rotation_min_degrees: Vector3 = Vector3(0, 0, 0)
@export var rock_rotation_max_degrees: Vector3 = Vector3(360, 360, 360)

# --- Overall Scaling ---
@export_group("Overall Scaling")
@export var overall_scale: float = 10.0

# --- Internal State ---
var chunk_coords: Vector2i = Vector2i.ZERO
var _grass_blade_mesh: ArrayMesh
var _tree_mesh: ArrayMesh
var _rock_mesh: ArrayMesh
var _sorted_grass_transforms: Array[Transform3D] = []
var _noise_path: FastNoiseLite # Reference to the global path noise generator.


func _ready() -> void:
	_grass_blade_mesh = _create_grass_blade_mesh()
	_tree_mesh = _create_tree_mesh()
	_rock_mesh = _create_rock_mesh()

func initialize_chunk(coords: Vector2i, path_noise: FastNoiseLite) -> void:
	chunk_coords = coords
	_noise_path = path_noise
	
	global_position.x = coords.x * chunk_size_x * overall_scale
	global_position.z = coords.y * chunk_size_z * overall_scale
	name = "Chunk_%d_%d" % [coords.x, coords.y]
	
	generate_terrain()
	setup_water_plane()
	generate_grass()
	generate_trees()
	generate_rocks()
	
	scale = Vector3(overall_scale, overall_scale, overall_scale)


func _create_grass_blade_mesh() -> ArrayMesh:
	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)
	var height = 0.2; var base_width = 0.04; var tip_width = 0.004
	var v0 = Vector3(-base_width, 0, 0); var v1 = Vector3(base_width, 0, 0)
	var v2 = Vector3(tip_width, height, 0); var v3 = Vector3(-tip_width, height, 0)
	st.set_uv(Vector2(0, 1)); st.add_vertex(v0); st.set_uv(Vector2(1, 1)); st.add_vertex(v1)
	st.set_uv(Vector2(1, 0)); st.add_vertex(v2); st.set_uv(Vector2(0, 0)); st.add_vertex(v3)
	st.add_index(0); st.add_index(1); st.add_index(3); st.add_index(1); st.add_index(2); st.add_index(3)
	if is_instance_valid(grass_material): st.set_material(grass_material)
	else:
		printerr("Grass Material not assigned in Chunk Inspector! Creating a bright magenta default.")
		var m = StandardMaterial3D.new(); m.albedo_color = Color.MAGENTA; m.cull_mode = BaseMaterial3D.CULL_DISABLED; st.set_material(m)
	st.generate_normals(); return st.commit()


func _create_tree_mesh() -> ArrayMesh:
	var st_trunk = SurfaceTool.new()
	st_trunk.begin(Mesh.PRIMITIVE_TRIANGLES)
	
	if is_instance_valid(tree_trunk_material):
		st_trunk.set_material(tree_trunk_material)
	else:
		printerr("Tree Trunk Material not assigned! Using a brown default.")
		var m = StandardMaterial3D.new(); m.albedo_color = Color("saddlebrown"); st_trunk.set_material(m)
		
	var trunk_height = 1.5; var trunk_width = 0.15
	var trunk_verts = [
		Vector3(-trunk_width, 0, -trunk_width), Vector3(trunk_width, 0, -trunk_width),
		Vector3(trunk_width, 0, trunk_width), Vector3(-trunk_width, 0, trunk_width),
		Vector3(-trunk_width, trunk_height, -trunk_width), Vector3(trunk_width, trunk_height, -trunk_width),
		Vector3(trunk_width, trunk_height, trunk_width), Vector3(-trunk_width, trunk_height, trunk_width)
	]
	var uv0 = Vector2(0, 1); var uv1 = Vector2(1, 1); var uv2 = Vector2(1, 0); var uv3 = Vector2(0, 0)
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[4]); st_trunk.set_uv(uv1); st_trunk.add_vertex(trunk_verts[5]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[1])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[4]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[1]); st_trunk.set_uv(uv3); st_trunk.add_vertex(trunk_verts[0])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[6]); st_trunk.set_uv(uv1); st_trunk.add_vertex(trunk_verts[7]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[3])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[6]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[3]); st_trunk.set_uv(uv3); st_trunk.add_vertex(trunk_verts[2])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[7]); st_trunk.set_uv(uv1); st_trunk.add_vertex(trunk_verts[4]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[0])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[7]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[0]); st_trunk.set_uv(uv3); st_trunk.add_vertex(trunk_verts[3])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[5]); st_trunk.set_uv(uv1); st_trunk.add_vertex(trunk_verts[6]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[2])
	st_trunk.set_uv(uv0); st_trunk.add_vertex(trunk_verts[5]); st_trunk.set_uv(uv2); st_trunk.add_vertex(trunk_verts[2]); st_trunk.set_uv(uv3); st_trunk.add_vertex(trunk_verts[1])
	st_trunk.generate_normals(); st_trunk.generate_tangents()

	var st_leaves = SurfaceTool.new()
	st_leaves.begin(Mesh.PRIMITIVE_TRIANGLES)
	
	if is_instance_valid(tree_leaves_material):
		st_leaves.set_material(tree_leaves_material)
	else:
		printerr("Tree Leaves Material not assigned! Using a green default.")
		var m = StandardMaterial3D.new(); m.albedo_color = Color("forestgreen"); st_leaves.set_material(m)
		
	var leaves_height = 1.2; var leaves_width = 0.7; var leaves_base_y = trunk_height
	var leaves_verts = [
		Vector3(-leaves_width, leaves_base_y, -leaves_width), Vector3(leaves_width, leaves_base_y, -leaves_width),
		Vector3(leaves_width, leaves_base_y, leaves_width), Vector3(-leaves_width, leaves_base_y, leaves_width),
		Vector3(-leaves_width, leaves_base_y + leaves_height, -leaves_width), Vector3(leaves_width, leaves_base_y + leaves_height, -leaves_width),
		Vector3(leaves_width, leaves_base_y + leaves_height, leaves_width), Vector3(-leaves_width, leaves_base_y + leaves_height, leaves_width)
	]
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[4]); st_leaves.set_uv(uv1); st_leaves.add_vertex(leaves_verts[5]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[1]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[4]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[1]); st_leaves.set_uv(uv3); st_leaves.add_vertex(leaves_verts[0]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[6]); st_leaves.set_uv(uv1); st_leaves.add_vertex(leaves_verts[7]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[3]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[6]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[3]); st_leaves.set_uv(uv3); st_leaves.add_vertex(leaves_verts[2]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[7]); st_leaves.set_uv(uv1); st_leaves.add_vertex(leaves_verts[4]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[0]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[7]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[0]); st_leaves.set_uv(uv3); st_leaves.add_vertex(leaves_verts[3]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[5]); st_leaves.set_uv(uv1); st_leaves.add_vertex(leaves_verts[6]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[2]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[5]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[2]); st_leaves.set_uv(uv3); st_leaves.add_vertex(leaves_verts[1]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[7]); st_leaves.set_uv(uv1); st_leaves.add_vertex(leaves_verts[6]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[5]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[7]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[5]); st_leaves.set_uv(uv3); st_leaves.add_vertex(leaves_verts[4]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[0]); st_leaves.set_uv(uv1); st_leaves.add_vertex(leaves_verts[1]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[2]);
	st_leaves.set_uv(uv0); st_leaves.add_vertex(leaves_verts[0]); st_leaves.set_uv(uv2); st_leaves.add_vertex(leaves_verts[2]); st_leaves.set_uv(uv3); st_leaves.add_vertex(leaves_verts[3]);
	st_leaves.generate_normals(); st_leaves.generate_tangents()

	var final_mesh = ArrayMesh.new()
	st_trunk.commit(final_mesh)
	st_leaves.commit(final_mesh, 0)
	return final_mesh


func _create_rock_mesh() -> ArrayMesh:
	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)

	if is_instance_valid(rock_material):
		st.set_material(rock_material)
	else:
		printerr("Rock Material not assigned in Chunk Inspector! Creating a gray default.")
		var m = StandardMaterial3D.new()
		m.albedo_color = Color.GRAY
		st.set_material(m)

	# Create an 8-vertex cube
	var size = 0.5
	var vertices = [
		Vector3(-size, -size, -size), Vector3(size, -size, -size),
		Vector3(size, -size,  size), Vector3(-size, -size,  size),
		Vector3(-size,  size, -size), Vector3(size,  size, -size),
		Vector3(size,  size,  size), Vector3(-size,  size,  size)
	]

	# Define faces using vertex indices
	var faces = [
		[0, 2, 1], [0, 3, 2], # Bottom
		[4, 5, 6], [4, 6, 7], # Top
		[0, 1, 5], [0, 5, 4], # Front
		[2, 3, 7], [2, 7, 6], # Back
		[1, 2, 6], [1, 6, 5], # Right
		[3, 0, 4], [3, 4, 7]  # Left
	]

	for face in faces:
		for vertex_index in face:
			st.add_vertex(vertices[vertex_index])
	
	st.generate_normals()
	#st.generate_tangents()
	
	return st.commit()

func generate_terrain() -> void:
	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)
	
	var step_x = chunk_size_x / float(vertices_x - 1)
	var step_z = chunk_size_z / float(vertices_z - 1)
	
	for z in range(vertices_z):
		for x in range(vertices_x):
			var vx = x * step_x
			var vz = z * step_z
			var wx = vx + chunk_coords.x * chunk_size_x
			var wz = vz + chunk_coords.y * chunk_size_z
			
			var raw_continent_noise = noise_continent.get_noise_2d(wx, wz)
			var normalized_continent_noise = (raw_continent_noise + 1.0) * 0.5
			var conceptual_base_height = lerp(continent_min_height, continent_max_height, normalized_continent_noise)
			
			var mountain_modulator = clamp((conceptual_base_height - mountain_start_height) / mountain_fade_height, 0.0, 1.0)
			var m_potential = max(0.0, noise_mountain.get_noise_2d(wx, wz)) * mountain_scale
			var m = m_potential * mountain_modulator
			
			var valley_carve = 0.0
			if conceptual_base_height < valley_apply_threshold:
				var valley_noise = noise_valley.get_noise_2d(wx, wz)
				var negative_valley = min(valley_noise, 0.0)
				var valley_modulator = clamp((valley_apply_threshold - conceptual_base_height) / valley_apply_threshold, 0.0, 1.0)
				valley_carve = negative_valley * valley_carve_scale * valley_modulator
			
			var erosion_modulator = 1.0 - abs(normalized_continent_noise - 0.5) * 2.0
			var bump_e = noise_erosion.get_noise_2d(wx, wz) * erosion_scale * erosion_modulator
			var c_slope_contribution = raw_continent_noise * continent_slope_scale
			
			var height = c_slope_contribution + m + valley_carve + bump_e
			var vertex = Vector3(vx, height, vz)
			
			var path_influence = 0.0
			if is_instance_valid(_noise_path):
				var path_noise_val = _noise_path.get_noise_2d(wx, wz)
				var path_centerline = abs(path_noise_val)
				path_influence = 1.0 - smoothstep(0.0, path_width, path_centerline)

			st.set_color(Color(path_influence, 0, 0, 1))

			var uv = Vector2(x / float(vertices_x - 1), z / float(vertices_z - 1))
			st.set_uv(uv)
			st.add_vertex(vertex)
			
	for z in range(vertices_z - 1):
		for x in range(vertices_x - 1):
			var i00 = z * vertices_x + x; var i10 = i00 + 1
			var i01 = (z + 1) * vertices_x + x; var i11 = i01 + 1
			st.add_index(i00); st.add_index(i10); st.add_index(i01)
			st.add_index(i10); st.add_index(i11); st.add_index(i01)
			
	st.generate_normals(); st.generate_tangents()
	
	var mesh: ArrayMesh = st.commit()
	mesh_instance.mesh = mesh
	
	var coll_shape = ConcavePolygonShape3D.new()
	coll_shape.set_faces(mesh.get_faces())
	collision_shape.shape = coll_shape


func setup_water_plane() -> void:
	var plane_mesh: PlaneMesh
	if water_mesh_instance.mesh is PlaneMesh and water_mesh_instance.mesh.size == Vector2(chunk_size_x, chunk_size_z):
		plane_mesh = water_mesh_instance.mesh
	else:
		plane_mesh = PlaneMesh.new()
		plane_mesh.size = Vector2(chunk_size_x, chunk_size_z)
		water_mesh_instance.mesh = plane_mesh
	
	water_mesh_instance.position = Vector3(chunk_size_x / 2.0, visual_water_level, chunk_size_z / 2.0)
	water_mesh_instance.visible = true


func generate_grass() -> void:
	_sorted_grass_transforms.clear()

	if not grass_multimesh or not is_instance_valid(_grass_blade_mesh): return
	var terrain_mesh: ArrayMesh = mesh_instance.mesh
	if not terrain_mesh or terrain_mesh.get_surface_count() == 0: return

	var mesh_arrays = terrain_mesh.surface_get_arrays(0)
	var vertices = mesh_arrays[Mesh.ARRAY_VERTEX]
	var normals = mesh_arrays[Mesh.ARRAY_NORMAL]
	var indices = mesh_arrays[Mesh.ARRAY_INDEX]
	var colors = mesh_arrays[Mesh.ARRAY_COLOR]
	if indices.is_empty() or colors.is_empty(): return

	var temp_transforms: Array[Transform3D] = []
	var mesh_global_transform = mesh_instance.global_transform

	for i in range(0, indices.size(), 3):
		var c0 = colors[indices[i]]; var c1 = colors[indices[i+1]]; var c2 = colors[indices[i+2]]
		var avg_path_influence = (c0.r + c1.r + c2.r) / 3.0
		
		if avg_path_influence > path_culling_threshold:
			continue

		var p0 = vertices[indices[i]]; var p1 = vertices[indices[i+1]]; var p2 = vertices[indices[i+2]]
		var avg_normal = (normals[indices[i]] + normals[indices[i+1]] + normals[indices[i+2]]).normalized()
		var local_avg_pos = (p0 + p1 + p2) / 3.0
		var world_avg_pos = mesh_global_transform * local_avg_pos
		
		if not (world_avg_pos.y > grass_min_height and world_avg_pos.y < grass_max_height): continue
		if avg_normal.y < grass_max_slope_normal_y: continue
		
		var area = (p1 - p0).cross(p2 - p0).length() * 0.5
		var world_area = area * (overall_scale * overall_scale)
		var num_clumps_to_spawn = floori(world_area * grass_density)

		for j in range(num_clumps_to_spawn):
			var r1 = randf(); var r2 = randf(); if r1 + r2 > 1.0: r1 = 1.0 - r1; r2 = 1.0 - r2
			var point_on_triangle = p0 + r1 * (p1 - p0) + r2 * (p2 - p0)
			
			var basis = Basis.IDENTITY
			var rot_x = deg_to_rad(randf_range(grass_rotation_min_degrees.x, grass_rotation_max_degrees.x))
			var rot_y = deg_to_rad(randf_range(grass_rotation_min_degrees.y, grass_rotation_max_degrees.y))
			var rot_z = deg_to_rad(randf_range(grass_rotation_min_degrees.z, grass_rotation_max_degrees.z))
			basis = basis.rotated(Vector3.UP, rot_y).rotated(Vector3.RIGHT, rot_x).rotated(Vector3.FORWARD, rot_z)
			basis = basis.scaled(Vector3.ONE * randf_range(grass_scale_min, grass_scale_max))
			
			var transform = Transform3D(basis, point_on_triangle)
			temp_transforms.append(transform)

	if temp_transforms.is_empty():
		grass_multimesh.multimesh = null; return

	var chunk_center = Vector3(chunk_size_x / 2.0, 0, chunk_size_z / 2.0)
	temp_transforms.sort_custom(
		func(a: Transform3D, b: Transform3D) -> bool:
			return a.origin.distance_squared_to(chunk_center) < b.origin.distance_squared_to(chunk_center)
	)
	_sorted_grass_transforms = temp_transforms

	var multimesh = MultiMesh.new()
	multimesh.transform_format = MultiMesh.TRANSFORM_3D
	multimesh.mesh = _grass_blade_mesh
	multimesh.instance_count = _sorted_grass_transforms.size()
	
	var buffer = PackedFloat32Array()
	buffer.resize(_sorted_grass_transforms.size() * 12); var idx = 0
	for t in _sorted_grass_transforms:
		buffer[idx+0]=t.basis.x.x; buffer[idx+1]=t.basis.x.y; buffer[idx+2]=t.basis.x.z; buffer[idx+3]=t.origin.x
		buffer[idx+4]=t.basis.y.x; buffer[idx+5]=t.basis.y.y; buffer[idx+6]=t.basis.y.z; buffer[idx+7]=t.origin.y
		buffer[idx+8]=t.basis.z.x; buffer[idx+9]=t.basis.z.y; buffer[idx+10]=t.basis.z.z; buffer[idx+11]=t.origin.z
		idx += 12
	multimesh.set_buffer(buffer)
	multimesh.visible_instance_count = _sorted_grass_transforms.size()
	grass_multimesh.multimesh = multimesh


func update_grass_lod(player_pos: Vector3) -> void:
	if not is_instance_valid(grass_multimesh) or not is_instance_valid(grass_multimesh.multimesh):
		return

	var local_aabb: AABB = mesh_instance.get_aabb()
	var world_aabb: AABB = global_transform * local_aabb
	
	var min_corner: Vector3 = world_aabb.position
	var max_corner: Vector3 = world_aabb.position + world_aabb.size
	
	var closest_point_on_aabb: Vector3 = player_pos.clamp(min_corner, max_corner)
	var distance_to_chunk = player_pos.distance_to(closest_point_on_aabb)

	var density_multiplier = lod_density_multipliers[lod_density_multipliers.size() - 1]
	for i in range(lod_distances.size()):
		if distance_to_chunk < lod_distances[i]:
			density_multiplier = lod_density_multipliers[i]
			break

	var total_instances = _sorted_grass_transforms.size()
	var visible_count = int(total_instances * density_multiplier)
	
	grass_multimesh.multimesh.visible_instance_count = visible_count


func generate_trees() -> void:
	if not tree_multimesh or not is_instance_valid(_tree_mesh): return
	var terrain_mesh: ArrayMesh = mesh_instance.mesh
	if not terrain_mesh or terrain_mesh.get_surface_count() == 0: return
	
	var mesh_arrays = terrain_mesh.surface_get_arrays(0)
	var vertices = mesh_arrays[Mesh.ARRAY_VERTEX]
	var normals = mesh_arrays[Mesh.ARRAY_NORMAL]
	var indices = mesh_arrays[Mesh.ARRAY_INDEX]
	var colors = mesh_arrays[Mesh.ARRAY_COLOR]
	if indices.is_empty() or colors.is_empty(): return
	
	var tree_transforms: Array[Transform3D] = []
	var rng = RandomNumberGenerator.new()

	var mesh_global_transform = mesh_instance.global_transform

	for i in range(0, indices.size(), 3):
		var c0 = colors[indices[i]]; var c1 = colors[indices[i+1]]; var c2 = colors[indices[i+2]]
		var avg_path_influence = (c0.r + c1.r + c2.r) / 3.0
		
		if avg_path_influence > path_culling_threshold:
			continue
			
		var p0 = vertices[indices[i]]; var p1 = vertices[indices[i+1]]; var p2 = vertices[indices[i+2]]
		var avg_normal = (normals[indices[i]] + normals[indices[i+1]] + normals[indices[i+2]]).normalized()
		var local_avg_pos = (p0 + p1 + p2) / 3.0
		var world_avg_pos = mesh_global_transform * local_avg_pos
		
		if not (world_avg_pos.y > tree_min_height and world_avg_pos.y < tree_max_height): continue
		if avg_normal.y < tree_max_slope_normal_y: continue
		if rng.randf() > tree_density: continue

		var r1 = rng.randf(); var r2 = rng.randf()
		if r1 + r2 > 1.0: r1 = 1.0 - r1; r2 = 1.0 - r2
		var point_on_triangle = p0 + r1 * (p1 - p0) + r2 * (p2 - p0)
		
		var basis = Basis.IDENTITY
		var rot_y = rng.randf_range(0, TAU)
		basis = basis.rotated(Vector3.UP, rot_y)
		basis = basis.scaled(Vector3.ONE * rng.randf_range(tree_scale_min, tree_scale_max))
		
		var transform = Transform3D(basis, point_on_triangle)
		tree_transforms.append(transform)

	if tree_transforms.is_empty(): tree_multimesh.multimesh = null; return
	var multimesh = MultiMesh.new(); multimesh.transform_format = MultiMesh.TRANSFORM_3D
	multimesh.mesh = _tree_mesh; multimesh.instance_count = tree_transforms.size()
	var buffer = PackedFloat32Array(); buffer.resize(tree_transforms.size() * 12); var idx = 0
	for t in tree_transforms:
		buffer[idx+0]=t.basis.x.x; buffer[idx+1]=t.basis.x.y; buffer[idx+2]=t.basis.x.z; buffer[idx+3]=t.origin.x
		buffer[idx+4]=t.basis.y.x; buffer[idx+5]=t.basis.y.y; buffer[idx+6]=t.basis.y.z; buffer[idx+7]=t.origin.y
		buffer[idx+8]=t.basis.z.x; buffer[idx+9]=t.basis.z.y; buffer[idx+10]=t.basis.z.z; buffer[idx+11]=t.origin.z
		idx += 12
	multimesh.set_buffer(buffer); tree_multimesh.multimesh = multimesh


func generate_rocks() -> void:
	if not rock_multimesh or not is_instance_valid(_rock_mesh): return
	var terrain_mesh: ArrayMesh = mesh_instance.mesh
	if not terrain_mesh or terrain_mesh.get_surface_count() == 0: return

	var mesh_arrays = terrain_mesh.surface_get_arrays(0)
	var vertices = mesh_arrays[Mesh.ARRAY_VERTEX]
	var normals = mesh_arrays[Mesh.ARRAY_NORMAL]
	var indices = mesh_arrays[Mesh.ARRAY_INDEX]
	var colors = mesh_arrays[Mesh.ARRAY_COLOR]
	if indices.is_empty() or colors.is_empty(): return
	
	var rock_transforms: Array[Transform3D] = []
	var rng = RandomNumberGenerator.new()

	var mesh_global_transform = mesh_instance.global_transform

	for i in range(0, indices.size(), 3):
		var c0 = colors[indices[i]]; var c1 = colors[indices[i+1]]; var c2 = colors[indices[i+2]]
		var avg_path_influence = (c0.r + c1.r + c2.r) / 3.0
		
		if avg_path_influence > path_culling_threshold:
			continue
			
		var p0 = vertices[indices[i]]; var p1 = vertices[indices[i+1]]; var p2 = vertices[indices[i+2]]
		var avg_normal = (normals[indices[i]] + normals[indices[i+1]] + normals[indices[i+2]]).normalized()
		var local_avg_pos = (p0 + p1 + p2) / 3.0
		var world_avg_pos = mesh_global_transform * local_avg_pos
		
		if not (world_avg_pos.y > rock_min_height and world_avg_pos.y < rock_max_height): continue
		if avg_normal.y < rock_max_slope_normal_y: continue
		if rng.randf() > rock_density: continue

		var r1 = rng.randf(); var r2 = rng.randf()
		if r1 + r2 > 1.0: r1 = 1.0 - r1; r2 = 1.0 - r2
		var point_on_triangle = p0 + r1 * (p1 - p0) + r2 * (p2 - p0)
		
		var basis = Basis.IDENTITY
		var rot_x = deg_to_rad(rng.randf_range(rock_rotation_min_degrees.x, rock_rotation_max_degrees.x))
		var rot_y = deg_to_rad(rng.randf_range(rock_rotation_min_degrees.y, rock_rotation_max_degrees.y))
		var rot_z = deg_to_rad(rng.randf_range(rock_rotation_min_degrees.z, rock_rotation_max_degrees.z))
		basis = basis.rotated(Vector3.RIGHT, rot_x).rotated(Vector3.UP, rot_y).rotated(Vector3.FORWARD, rot_z)
		basis = basis.scaled(Vector3.ONE * rng.randf_range(rock_scale_min, rock_scale_max))
		
		var transform = Transform3D(basis, point_on_triangle)
		rock_transforms.append(transform)

	if rock_transforms.is_empty(): 
		rock_multimesh.multimesh = null
		return
		
	var multimesh = MultiMesh.new()
	multimesh.transform_format = MultiMesh.TRANSFORM_3D
	multimesh.mesh = _rock_mesh
	multimesh.instance_count = rock_transforms.size()
	
	var buffer = PackedFloat32Array()
	buffer.resize(rock_transforms.size() * 12)
	var idx = 0
	for t in rock_transforms:
		buffer[idx+0]=t.basis.x.x; buffer[idx+1]=t.basis.x.y; buffer[idx+2]=t.basis.x.z; buffer[idx+3]=t.origin.x
		buffer[idx+4]=t.basis.y.x; buffer[idx+5]=t.basis.y.y; buffer[idx+6]=t.basis.y.z; buffer[idx+7]=t.origin.y
		buffer[idx+8]=t.basis.z.x; buffer[idx+9]=t.basis.z.y; buffer[idx+10]=t.basis.z.z; buffer[idx+11]=t.origin.z
		idx += 12
	multimesh.set_buffer(buffer)
	
	rock_multimesh.multimesh = multimesh
